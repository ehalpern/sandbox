<html>
<head>
  <title>Frame - Activator Template</title>
</head>
<body>

<div>
  <h2>Config, Guice, Akka and Spray</h2>

  <p>
    Presents a light framework for building reactive REST services in a modular,
    testable fashion using Typesafe Config, Guice, Akka and Spray.
  </p>

  <p>
    This tutorial will demonstrate:
  <ul>
    <li>
      How to use dependency injection to simplify and modularize code (and tame implicits)
    </li>
    <li>
      How to inject configuration properties to avoid boilerplate configuration code
    </li>
    <li>
      Clear, concise patterns for implementing reactive, end-to-end REST services using Spray
    </li>
    <li>
      How to combine these techniques to provide a simple, complete, scalable structure for
      building REST server applications
    </li>
  </ul>
  </p>
</div>
<div>
  <h2>The Example - A World Climate API</h2>
  <p>
    We'll explore a simple but complete example -
    A REST API that provides historical climate data by country.
  </p>
  <p>
    Here are the key components:
    <ul>
      <li>
        <a href="#code/src/main/scala/sandbox/app/climate/ClimateService.scala" class="shortcut">ClimateService</a>
        provides world climate data by time period and country
      </li>
      <li>
        <a href="#code/src/main/scala/sandbox/app/climate/wbclimate/WbClimateClient.scala" class="shortcut">WbClimateClient</a>
        is used by the ClimateService implementation to access the
        <a href="http://data.worldbank.org/developers/climate-data-api">World Bank Climate API</a>
      </li>
      <li>
        <a href="#code/src/main/scala/sandbox/app/climate/ClimateApi.scala" class="shortcut">ClimateAPI</a>
        exposes the ClimateService results as a REST API
      </li>
    </ul>
  </p>
</div>
<div>
  <h2>Dependency Injection</h2>
  <p>
    Dependency injection (DI) provides a concise way to wire applications together.
    It removes the need for <code><b>new</b></code> and factories (both of which
    tend to complicate code and interfere with modularity).
  </p>
  <p>
    When using a DI system, each implementation class can simply declare its dependencies
    in its constructor and rely on the system to provide them on instantiation.
  </p>
  <p>
    The <a href="#code/src/main/scala/sandbox/app/climate/ClimateService.scala" class="shortcut">ClimateServiceImpl</a>
    class provides a simple example. It declares two dependencies:
  <ul>
    <li>
      A <a href="#code/src/main/scala/sandbox/app/climate/wbclimate/WbClimateClient.scala" class="shortcut">WbClimateClient</a>
      used to access World Bank climate data
    </li>
    <li>
      An implicit
      <a href="http://www.scala-lang.org/files/archive/nightly/docs/library/index.html#scala.concurrent.ExecutionContext">ExecutionContext</a>
      used to execute futures
    </li>
  </ul>
  The DI system will provide both of these automatically when it instantiates the service.
  </p>
  <p>
    Noticed the ugly <code>@Inject()</code> annotation?  Guice (and JSR 330) requires this to
    mark all constructors that are are candidates for injection.
  </p>
</div>
<div>
  <h2>Configuration Injection</h2>
  <p>
    An implementation may also require configuration, and we can use DI for this too.
  </p>
  <p>
    <a href="#code/src/main/scala/sandbox/app/climate/WbClimateClient.scala" class="shortcut">WbClimateClientImpl</a>
    provides an example.
    It declares an <code>endpoint</code> constructor parameter
    <pre><code>@Named("wbclient.endpoint") endpoint: String</code></pre>
    used to access the World Bank API.
  </p>
  <p>
    This annotation tells the DI system that the value should be read from the "wbclient.endpoint"
    configuration property (defined in
    <a href="#code/conf/application.conf" class="shortcut">application.conf</a>)
  </p>
  <p>
    The
    <a href="https://code.google.com/p/google-guice/wiki/BindingAnnotations#@Named">@Named</a>
    annotation is a Guice/JSR330 way to qualify a dependency that cannot be identified by
    its type alone.
  </p>
  <p>
    <h3>Behind the scene</h3>
    During DI system initialization, we load a special
    <a href="#code/src/main/scala/sandbox/frame/config/ConfigModule.scala" class="shortcut">ConfigModule</a>
    that reads the typesafe configuration and binds each property value to a <code>@Named("[config-key]")</code>
    annotation. This makes all config properties available for injection.
  </p>
</div>
<div>
  <h2>Modules and Bindings</h2>
  <p>
    The complete application is composed of a set of modules.  Each module defines a logical
    subsystem and contains all necessary implementation bindings.
  </p>
  <p>
    The program entry point
    <a href="#code/src/main/scala/sandbox/Main.scala" class="shortcut">Main</a>
    wires the application by installing
    <a href="#code/src/main/scala/sandbox/MainModule.scala" class="shortcut">MainModule</a>.
    This module, in turn, installs all of the sub-modules required required to start the server:
    <ul>
      <li>
        <a href="#code/src/main/scala/sandbox/frame/config/ConfigModule.scala" class="shortcut">ConfigModule</a>
        loads the Typesafe configuration and creates a @Named binding for every configuration property
      </li>
      <li>
        <a href="#code/src/main/scala/sandbox/frame/akka/AkkaModule.scala" class="shortcut">AkkaModule</a>
        initializes the Akka system and wires Akka to use Guice for actor instantiation.  This module also
        binds the AkkaRefFactory and ExecutionContext so they're available for injection to all services that
        use Akka and Futures.
      </li>
      <li>
        <a href="#code/src/main/scala/sandbox/app/ServicesModule.scala" class="shortcut">ServicesModule</a>
        binds all application services
      </li>
      <li>
        <a href="#code/src/main/scala/sandbox/frame/spray/SprayModule.scala" class="shortcut">SprayModule</a>
        enables an Http Server and creates the actor to handle requests
      </li>
      <li>
        <a href="#code/src/main/scala/sandbox/app/ApisModule.scala" class="shortcut">ApisModule</a>
        registers all REST APIs
      </li>
    </ul>
  </p>
</div>
<div>
  <h2>Implementing the REST API</h2>
  <p>
    <a href="#code/src/main/scala/sandbox/app/climate/ClimateApi.scala" class="shortcut">ClimateApi</a>
    implements the REST API in our example.
  </p>
  <p>
    It defines a read-only climate resource that can be used to obtain climate data for a
    particular location for a particular time period (fromYear - toYear), and it uses a
    <a href="#code/src/main/scala/sandbox/app/climate/ClimateService.scala" class="shortcut">ClimateService</a>
    to obtain the data.
  </p>
  </p>
  <p>
    The GET looks simple, but there's more to it than meets the eye.  The complete block is
    asynchronous:
<pre><code>
  complete {
    climateService.query(location, from, to)
  }
</code></pre>
    The  <a href="#code/src/main/scala/sandbox/app/climate/ClimateService.scala" class="shortcut">climateService.query</a>
    call returns a Future.  The complete directive obtains this Future, registers a
    completion callback and returns.  At this point, the request handling thread is done.
  </p>
  <p>
    When the Future later completes, the callback marshals the result to JSON and
    sends a response through the socket that made the request.
  </p>
  <p>
    So the code is easy to read sequentially, but it is executed asynchronously.
  </p>
</div>
<div>
  <h2>Implementing ClimateService</h2>
  <p>
    <a href="#code/src/main/scala/sandbox/app/climate/ClimateService.scala" class="shortcut">ClimateServiceImpl</a>
    implements a single <code>query</code> method for obtaining climate data.
  </p>
  <p>
    The method makes two requests to the World Bank Climate API and
    combines the results into a single
    <a href="#code/src/main/scala/sandbox/app/climate/model/ClimateQueryResult.scala" class="shortcut">ClimateQueryResult</a>.
  </p>
  <p>
    Although it reads sequentially, the code is actually asynchronous.
<pre><code>
(for {
  temp <- wbClient.fetchTemperatureStats(location, fromYear, toYear)
  rain <- wbClient.fetchPrecipitationStats(location, fromYear, toYear)
} yield {
  ClimateStats.fromData(location, fromYear, toYear, temp, rain)
})
</code></pre>
    Both <code>wbClient</code> calls return Future[WbClimateData].
    The <b>for</b> comprehension actually combines these Futures into a new Future[ClimateStats]
    which completes with the combined result.
  </p>
    Under the covers, it is simply using
    <a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.Future@map[S](f:T=>S)(implicitexecutor:scala.concurrent.ExecutionContext):scala.concurrent.Future[S]">
      Future.map and flatMap
    </a>
    to build a chain of callbacks.
  </p>
  <p>
    The last map call
<pre><code>
}) map { stats =>
  ClimateQueryResult(List(stats))
}
</code></pre>
    adds a final step to the chain that transforms the data to a ClimateQueryResult.
  </p>
</div>
<div>
  <h2>Implementing an Async API Client</h2>
  <p>
    <a href="#code/src/main/scala/sandbox/app/climate/wbclimate/WbClimateClient.scala" class="shortcut">WbClimateClientImpl</a>
    implements the async http client for the World Bank Climate API using:
    <ul>
      <li>
        <a href="http://spray.io/documentation/1.2.1/spray-client/">Spray Client</a>
        to handle async HTTP
      </li>
      <li>
        <a href="http://json4s.org/">Json4s</a>
        to handle json unmarshalling
      </li>
    </ul>
  </p>
  <p>
    Let's take a look at
    <a href="#code/src/main/scala/sandbox/app/climate/wbclimate/WbClimateClient.scala" class="shortcut">fetchTemperatureStats</a>
    to see how things fit together.
  </p>
  <p>
    The first line builds a URI.  The second, <code>pipeline(Get(uri))</code>,
    puts a Get request into the processing pipeline.
  </p>
  <p>
    The pipeline defines the stages for http processing:
<pre><code>
val pipeline: HttpRequest => Future[Seq[WbClimateData]] =
  sendReceive ~>
    unmarshal[Seq[WbClimateData]]
</code></pre>
  </p>
  <p>
    The <code>sendReceive</code> stage sends the request
    (using <a href="http://doc.akka.io/docs/akka/snapshot/scala/io.html">Akka IO</a>)
    and processes the response on completion.
  </p>
  <p>
    The <code>unmarshal</code> stage deserializes the response into Seq{WbClimateData].  We've employed Json4s
    to handle unmashalling by mixing in
    <a href="#code/src/main/scala/sandbox/app/climate/wbclimate/WbClimateData.scala" class="shortcut">WbClimateData.JsonProtocol</a>.
  </p>
  <p>
    As we've seen before, the pipeline is easy to understand sequentially but is actually implemented under the
    covers as an async chain of (future completion) callbacks.
  </p>
</div>
<div>
  <h2>Unit Testing the API</h2>
  <p>
    <a href="#code/src/test/scala/sandbox/app/climate/ClimateApiSpec" class="shortcut">ClimateApiSpec</a>
    defines the unit test for <a href="#code/src/main/scala/sandbox/app/climate/ClimateApi" class="shortcut">ClimateApi</a>.
  </p>
  <p>
    It uses the spray testkit and the Mokito mocking framework to run an isolated
    test against ClimateApi.  Rather than use dependency injection in this case,
    we instantiate the ClimateApi directly and pass in a mock service for it to run
    against.
  </p>
  <p>
    This test is structured so we can reuse it for running an integration test which
    we'll explore in next.
  </p>
</div>

<div>
  <h2>Integration Testing</h2>
  <p>
    <a href="#code/src/test/scala/sandbox/app/climate/ClimateApiIntegSpec" class="shortcut">ClimateApiIntegSpec</a>
    extends the unit test to run against a real service.
  </p>
  <p>
    Instead of creating route with ClimateApi and a mock ClientService, it uses
    the getAppRouteInstance defined in <a href="#code/src/test/scala/sandbox/IntegTestSupport" class="shortcut">IntegTestSupport</a>
  </p>
  <p>
    This returns a route that is implemented as the real application, which has been
    constructed using the DI framework.
  </p>
  <p>
    You can run this test using "sbt integ:test"
  </p>
</div>
</body>
</html>
